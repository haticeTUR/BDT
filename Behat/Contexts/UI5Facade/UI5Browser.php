<?php
namespace axenox\BDT\Behat\Contexts\UI5Facade;

use axenox\BDT\Behat\Contexts\UI5Facade\Nodes\GenericHtmlNode;
use axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5FilterNode;
use axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5PageNode;
use axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5TileNode;
use axenox\BDT\Interfaces\FacadeNodeInterface;
use axenox\BDT\Tests\Behat\Contexts\UI5Facade\ErrorManager;
use Behat\Mink\Element\NodeElement;
use Behat\Mink\Session;
use exface\Core\Actions\Login;
use exface\Core\CommonLogic\Security\Authenticators\MetamodelAuthenticator;
use exface\Core\CommonLogic\Workbench;
use exface\Core\DataTypes\ComparatorDataType;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Exceptions\InvalidArgumentException;
use exface\Core\Exceptions\RuntimeException;
use exface\Core\Factories\ActionFactory;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Factories\FacadeFactory;
use exface\Core\Factories\MetaObjectFactory;
use exface\Core\Factories\UiPageFactory;
use exface\Core\Interfaces\WorkbenchInterface;
use exface\UI5Facade\Facades\UI5Facade;
use PHPUnit\Framework\Assert;

/**
 * Allows to work with OpenUI5 apps generated by exface.UI5Facade
 * 
 *  This class provides methods for:
 * - Finding and interacting with UI5 controls
 * - Navigating within UI5 applications
 * - Handling UI5-specific wait conditions
 * - Monitoring AJAX/XHR requests
 * - Validating UI states and content
 * 
 * @author Andrej Kabachnik
 */
class UI5Browser
{
    private $session;
    private $workbench = null;
    private $facade = null;
    private $objectAlias = null;
    private UI5WaitManager $waitManager;
    private array $focusStack = [];

    private string $locale;

    /**
     * Constructor - initializes the UI5Browser with necessary dependencies
     * 
     * @param WorkbenchInterface $workbench The application workbench
     * @param mixed $session session for browser interaction
     * @param string $ui5AppUrl URL of the UI5 application to load
     */
    public function __construct(WorkbenchInterface $workbench, $session, string $ui5AppUrl, string $locale)
    {
        $this->session = $session;
        $this->workbench = $workbench;
        $this->waitManager = new UI5WaitManager($session);
        $this->locale = $locale;

        // Initialize XHR monitoring to track AJAX requests
        $this->initializeXHRMonitoring();
        // Clear error log
        ErrorManager::getInstance()->clearErrors();
        // Initial app load using waitManager to ensure it's fully loaded
        $this->waitManager->waitForAppLoaded($ui5AppUrl);
    }

    /**
     * Gets the wait manager instance that handles all wait operations
     * 
     * @return UI5WaitManager The wait manager instance
     */
    public function getWaitManager(): UI5WaitManager
    {
        return $this->waitManager;
    }

    /**
     * Returns the Mink session used for browser interaction
     * 
     * @return \Behat\Mink\Session Current browser session
     */
    protected function getSession(): Session
    {
        return $this->session;
    }


    /**
     * Returns the workbench instance for the application
     * 
     * @return Workbench Application workbench
     */
    public function getWorkbench()
    {
        return $this->workbench;
    }

    /**
     * Returns the locale information about session
     * 
     * @return string
     */
    public function getLocale(): string
    {
        return $this->locale;
    }

    /**
     * Gets the UI5Facade instance used for UI5-specific operations
     * Lazy-loads the facade if not already instantiated
     * 
     * @return \exface\UI5Facade\Facades\UI5Facade UI5 facade instance
     */
    public function getFacade(): UI5Facade
    {
        if ($this->facade === null) {
            $this->facade = FacadeFactory::createFromString(UI5Facade::class, $this->getWorkbench());
        }
        return $this->facade;
    }

    /**
     * Sets the object alias used for filtering widget search results
     * This allows targeting specific widgets that contain the given alias text
     * For example, if searching for a table related to "Customer" data,
     * setting objectAlias to "Customer" will only return widgets containing that text
     *
     * @param string|null $alias The text to filter widgets by, null to clear filter
     * @return void
     */
    public function setObjectAlias(?string $alias): void
    {
        $this->objectAlias = $alias;
    }

    /**
     * Gets the current object alias used for widget filtering
     * Returns the text currently being used to filter widget search results,
     * or null if no filtering is active
     *
     * @return string|null The current object alias or null if not set
     */
    public function getObjectAlias(): ?string
    {
        return $this->objectAlias;
    }

    /**
     * Returns the current page object from the Mink session
     * 
     * @return \Behat\Mink\Element\DocumentElement Current page object
     */
    public function getPage()
    {
        return $this->session->getPage();
    }



    /**
     * Clears the XHR (XMLHttpRequest) monitoring log and resets error state
     * 
     * This function performs two main cleanup tasks:
     * 1. Clears the XHR log array in the browser (window.exfXHRLog)
     * 2. Resets the internal error tracking state
     * 
     * Use cases:
     * - Before starting a new test scenario
     * - After completing a test case
     * - When needing to reset monitoring state
     * - Before capturing new AJAX requests
     * 
     * Note: This should be called before any new AJAX monitoring to ensure
     * clean state and prevent mixing logs from different test scenarios
     * 
     * @return void
     * @see initializeXHRMonitoring() For the setup of the logging system
     */
    public function clearXHRLog(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            window.exfXHRLog = {
                requests: [],
                lastRequest: null,
                errors: []
            };
            JS
        );
    }

    /**
     * Clears all widget highlights and debug labels from the UI
     * 
     * This method removes:
     * - Outline and border styles from previously highlighted elements
     * - Global highlight indicators 
     * 
     * @throws \RuntimeException If script execution fails
     */
    public function clearWidgetHighlights(): void
    {

        try {
            $debugScript = <<<JS
            // Remove outline and border styles from highlighted elements    
            document.querySelectorAll('[style*="outline"]').forEach(el => { 
                el.style.outline = '';
                el.style.border = '';
            });

            // Call global highlight clearing function if it exists
            if (window.clearHighlight && typeof window.clearHighlight === 'function') {

                window.clearHighlight();
            }

            // Remove all debug labels
            document.querySelectorAll('.debug-highlight-label').forEach(label => {
                label.remove();
            });

            JS;

            $this->session->executeScript($debugScript);
        } catch (\Exception $e) {
            // Throw a more specific RuntimeException with the original exception as the previous exception
            throw new \RuntimeException(
                "Failed to clear widget highlights: " . $e->getMessage(),
                0,
                $e
            );
        }
    }



    /**
     * Handles wait operations before or after test steps
     * 
     * This method ensures the UI is in a stable state by waiting for:
     * - AJAX requests to complete
     * - UI5 busy indicators to disappear 
     * 
     * @param bool $isAfterStep True if called after a step, false if before
     * @return void
     * @throws \RuntimeException If wait operation fails
     */
    public function handleStepWaitOperations(bool $isAfterStep = true): void
    {
        try {
            if ($isAfterStep) {
                //$this->clearWidgetHighlights();
                // After step: Wait for all operations to complete
                $this->waitManager->waitForPendingOperations(true, true, true);

            } else {
                // Before step: Limited wait for UI stabilization
                $this->waitManager->waitForPendingOperations(false, true, false);
            }
        } catch (\Exception $e) {
            throw new \RuntimeException(
                sprintf(
                    "Wait operation failed (%s step): %s",
                    $isAfterStep ? 'after' : 'before',
                    $e->getMessage()
                )
            );
        }
    }

    public function getFocusStackForDebugging(): array
    {
        return $this->focusStack;
    }

    public function clearFocusStack(): void
    {
        $this->focusStack = []; // Focus stackini sıfırla

        // Opsiyonel: JavaScript ile de UI tarafında temizlik yapılabilir
        $this->session->executeScript('
        // if exist UI5 side focus clearing
        if (window.clearFocus) {
            window.clearFocus();
        }
    ');
    }

    /**
     * Highlights a widget with visual indicator for debugging purposes
     * 
     * Adds a colored outline and label to the widget to make it visible
     * during test execution and debugging
     * 
     * @param NodeElement $node Widget element to highlight
     * @param string $widgetType Type of the widget (used in label)
     * @param int $index Index number of the widget
     * @throws \RuntimeException If highlighting script execution fails
     * @return void
     */
    public function highlightWidget(NodeElement $node, string $widgetType, int $index): void
    {
        // Define color palette for different widget types
        $colors = [
            'DataTable' => '#4CAF50',  // Green
            'Dialog' => '#2196F3',     // Blue
            'Input' => '#FF9800',      // Orange
            'default' => '#9C27B0'     // Purple
        ];

        // Select color based on widget type, fallback to default
        $color = $colors[$widgetType] ?? $colors['default'];

        try {
            $highlightScript = sprintf(<<<JS
        (function() {
            const el = document.querySelector("#%s");
            if (el) {

                // Clear previous highlights
                el.style.outline = 'none';
                
                // Add new highlight
                el.style.outline = '5px solid %s';
                el.style.outlineOffset = '4px';

                // Remove existing debug label if present
                const existingLabel = el.querySelector('.debug-highlight-label');
                if (existingLabel) {
                    existingLabel.remove();
                }

                // Create new debug label
                const label = document.createElement('div');
                label.className = 'debug-highlight-label';
                label.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    background: %s;
                    color: white;
                    padding: 2px;
                    font-size: 10px;
                    z-index: 9999;
                `;
                label.textContent = '%s #%d';
                
                el.appendChild(label);

                // Call global highlight function if it exists
                if (window.highlightElement && typeof window.highlightElement === 'function') {
                    window.highlightElement(el, '%s', '%s #%d');
                }
            }
        })();
        JS,
                $node->getAttribute('id'),
                $color,
                $color,
                $widgetType,
                $index + 1,
                $color,
                $widgetType,
                $index + 1,
                $node->getAttribute('id')  // Add ID to warning message
            );

            // Execute the highlighting script
            $this->session->executeScript($highlightScript);

        } catch (\Exception $e) {
            // Throw a more specific RuntimeException with context
            throw new \RuntimeException(
                sprintf(
                    "Failed to highlight widget (Type: %s, Index: %d): %s",
                    $widgetType,
                    $index,
                    $e->getMessage()
                ),
                0,
                $e
            );
        }
    }

    /**
     * Displays the name of the current test case on the UI.
     * 
     * This function creates a fixed position message div on the page 
     * that shows the name of the test case being executed. The div 
     * is styled to be visually distinct, with a selected colour background 
     * and white text, making it easy to identify during test execution.
     * 
     * The message div is created if it does not already exist, ensuring 
     * that it does not duplicate if the function is called multiple times.
     * 
     * @param string $testCaseName The name of the test case to display.
     * @return void
     */
    public function showTestCaseName(string $testCaseName): void
    {
        $this->session->executeScript(<<<JS
    (function() {
        // Check if the message div already exists
        let messageDiv = document.getElementById('testCaseNameDiv');
        
        // If it doesn't exist, create it
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'testCaseNameDiv'; // Set an ID for future reference
            messageDiv.style.position = 'fixed';
            messageDiv.style.top = '10px';
            messageDiv.style.right = '10px';
            messageDiv.style.backgroundColor = '#4CAF50'; // Green
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '10px';
            messageDiv.style.borderRadius = '5px';
            messageDiv.style.zIndex = '9999';
            document.body.appendChild(messageDiv); 
        }
        
        // Update the text of the message div
        messageDiv.innerText = '' + '{$testCaseName}';
    })();
JS
        );
    }

    /**
     * Displays step timing information on the UI.
     * 
     * This function creates a fixed position message div on the page 
     * that shows the timing information for test steps. It displays:
     * - Step start time when a step begins
     * - Both start and end times plus duration when a step completes
     * 
     * The div is styled to be visually distinct from the test case name div,
     * positioned at the bottom right of the screen.
     * 
     * @param string $stepName The name of the step being executed
     * @param bool $isStepStart Whether this is the start or end of the step
     * @param float|null $startTime The start time of the step (timestamp)
     * @return float Current timestamp (can be used as startTime for end call)
     */
    public function showStepTiming(string $stepName, bool $isStepStart = true, ?float $startTime = null): float
    {
        $currentTime = microtime(true);
        $formattedTime = date('H:i:s', (int) $currentTime) . '.' . substr(number_format($currentTime - (int) $currentTime, 3), 2);

        if ($isStepStart) {
            // For step start, just show the start time
            $message = "Started at: {$formattedTime}";
        } else {
            // For step end, show start, end and duration
            $duration = $currentTime - $startTime;
            $formattedStartTime = date('H:i:s', (int) $startTime) . '.' . substr(number_format($startTime - (int) $startTime, 3), 2);
            $message = "Started: {$formattedStartTime}<br>Ended: {$formattedTime}<br>Duration: " . number_format($duration, 3) . " sec";
        }

        // Convert PHP boolean to JavaScript boolean string
        $isStepStartJS = $isStepStart ? 'false' : 'true';

        $this->session->executeScript(<<<JS
    (function() {
        // Check if the timing div already exists
        let timingDiv = document.getElementById('stepTimingDiv');
        
        // If it doesn't exist, create it
        if (!timingDiv) {
            timingDiv = document.createElement('div');
            timingDiv.id = 'stepTimingDiv';
            timingDiv.style.position = 'fixed';
            timingDiv.style.bottom = '10px';
            timingDiv.style.right = '10px';
            timingDiv.style.backgroundColor = '#2196F3'; // Blue color to distinguish from test case name
            timingDiv.style.color = 'white';
            timingDiv.style.padding = '10px';
            timingDiv.style.borderRadius = '5px';
            timingDiv.style.zIndex = '9999';
            timingDiv.style.fontFamily = 'monospace'; // For better readability of times
            timingDiv.style.fontSize = '14px';
            timingDiv.style.maxWidth = '300px'; 
            timingDiv.style.pointerEvents = 'none'; // Able to clicks
            
            

            document.body.appendChild(timingDiv);
        }
        
        // Updading the text of the timing div
        timingDiv.innerHTML = '<strong>Step: {$stepName}</strong><br>' + '{$message}';
        
        // If this is the end of the step, wait 1 second and then update the div
        if ({$isStepStartJS}) {
            setTimeout(function() {
                timingDiv.innerHTML += '<br><em>Continuing in 1s...</em>';
            }, 0);
            
            // Wait 0,5 seconds before next step
            setTimeout(function() {
                // You can clear or update the message here if needed
            }, 500);
        }
    })();
JS
        );

        // Return current time so it can be used as startTime for the end call
        return $currentTime;
    }



    /**
     * Helper function to get widget location description
     * Used to provide context about where in the UI a widget is located
     * 
     * @param NodeElement $widget The widget to get location for
     * @return string Human-readable location description
     */
    public function getWidgetLocation(NodeElement $widget): string
    {
        $parent = $widget->find('xpath', './ancestor::*[contains(@class, "sapMPage") or contains(@class, "sapMPopup")][1]');
        if ($parent) {
            $title = $parent->find('css', '.sapMTitle');
            if ($title) {
                return "in " . trim($title->getText());
            }
        }
        return "in page";
    }

    /**
     * Sets focus on a node and maintains a focus stack
     * Used to track which elements have focus during test execution
     * 
     * @param NodeElement|FacadeNodeInterface $node The element to focus
     * @return void
     */
    public function focus($node): void
    {
        switch (true) {
            case $node instanceof FacadeNodeInterface:
                // everything is finde
                break;
            case $node instanceof NodeElement:
                $node = new GenericHtmlNode($node, $this->getSession(), $this);
                break;
            default:
                throw new InvalidArgumentException('Cannot focus on "' . gettype($node) . '": expecting Mink NodeElement or FacadeNodeInterface');
        }
        $top = end($this->focusStack);
        if ($top !== $node) {
            $this->focusStack[] = $node;
        }
    }

    /**
     * Gets the currently focused node
     * Returns the top element of the focus stack
     * 
     * @return FacadeNodeInterface The focused element or null if none focused
     */
    public function getFocusedNode(): FacadeNodeInterface
    {
        if (empty($this->focusStack)) {
            return new UI5PageNode($this->getPage()->find('css', 'body'), $this->getSession(), $this);
        }
        $top = end($this->focusStack);
        return $top;
    }

    /**
     * Removes the current focus from the widget stack
     * 
     * @description Pops the top element from the focus stack, effectively unfocusing the current widget
     */
    public function unfocus(): void
    {
        if (!empty($this->focusStack)) {
            array_pop($this->focusStack);
        }
    }

    /**
     * Completely clears the entire focus stack
     * 
     * @description Resets the focus stack to an empty state, removing all previously focused widgets
     */
    public function clearFocus(): void
    {
        $this->focusStack = [];
    }

    /**
     * Gets current URL with hash fragment
     * This ensures we get the complete URL including UI5 routing information
     * 
     * @return string Complete URL including hash
     */
    public function getCurrentUrlWithHash(): string
    {
        return $this->session->evaluateScript('
        (function() {
            var baseUrl = window.location.href;
            var hash = window.location.hash;
            
            // Check for UI5 specific hash handling
            if (typeof sap !== "undefined" && 
                sap.ui && 
                sap.ui.core && 
                sap.ui.core.routing && 
                sap.ui.core.routing.HashChanger) {
                
                try {
                    // Get hash from UI5 router
                    hash = "#" + sap.ui.core.routing.HashChanger.getInstance().getHash();
                } catch(e) {
                    // Fallback to browser hash if UI5 router not available
                    console.warn("UI5 router not available:", e);
                }
            }
            
            // Ensure we don\'t duplicate the hash
            baseUrl = baseUrl.split("#")[0];
            
            return baseUrl + (hash || "");
        })();
    ');
    }


    /**
     * Verifies table content against expected values
     * Checks if specified column contains expected text
     * 
     * @param NodeElement $table The table to verify
     * @param array $expectedContent Array of expected content (column => text pairs)
     * @return void
     * @throws \RuntimeException If verification fails
     */
    public function verifyTableContent(NodeElement $table, array $expectedContent): void
    {
        try {
            // Check each expected content item
            foreach ($expectedContent as $content) {
                $columnName = $content['column'];
                $searchValue = trim($content['value'], '"\'');
                $rawCmp = $content['comparator'] ?? '==';

                // First find column headers
                $headers = $table->findAll('css', '.sapUiTableHeaderDataCell label, .sapMListTblHeader .sapMColumnHeader');
                $columnIndex = null;

                // Find the column index
                foreach ($headers as $index => $header) {
                    $headerText = trim($header->getText());
                    if ($headerText === $columnName) {
                        $columnIndex = $index;
                        break;
                    }
                }

                Assert::assertNotNull($columnIndex, "Column '$columnName' not found in table");

                // Check table cells
                $rows = $table->findAll(
                    'css',
                    // data scrollers: fixed + scrollable
                    '.sapUiTableCtrlFixed .sapUiTableTr.sapUiTableContentRow[role="row"]:not(.sapUiTableRowHidden), ' .
                    '.sapUiTableCtrl .sapUiTableTr.sapUiTableContentRow[role="row"]:not(.sapUiTableRowHidden)'
                );
                $considered = 0;
                $matches = 0;
                $firstFailures = []; // collect first few failures for better error messages
                foreach ($rows as $row) {
                    if ($row->getAttribute('aria-hidden') === 'true') {
                        continue;
                    }

                    $cells = $row->findAll('css', '.sapUiTableCell, .sapMListTblCell');
                    if (count($cells) === 0) {
                        continue; // row has no cells at all
                    }
                    if (!isset($cells[$columnIndex])) {
                        continue;
                    }
                   
                    // Extract visible text from the target cell
                    $cell = $cells[$columnIndex];

                    $cellText = $this->extractCellText($cell); // see helper below

                    // Skip truly empty rows (no content at all)
                    if ($cellText === '') {
                        // If you want empty to be considered a value, remove this continue
                        continue;
                    }

                    $considered++;

                    // Strict comparison using your limited operator set
                    $ok = $this->compareCell($cellText, $searchValue, $rawCmp);

                    if ($ok) {
                        $matches++;
                    } else {
                        if (count($firstFailures) < 3) {
                            $firstFailures[] = $cellText;
                        }
                    }
                }

                Assert::assertSame(
                    $considered,
                    $matches,
                    "Not all rows of the table fits the column '{$columnName}'. {$matches}/{$considered} matched. First mismatches: " . implode(' | ', $firstFailures)
                );
                
            }
        } catch (\Exception $e) {
            throw new \RuntimeException(
            // sprintf(
            //     "Failed to verify table content. Error: %s\nTable structure: %s",
            //     $e->getMessage(),
            //     $table->getOuterHtml()
            // )
                sprintf(
                    "Failed to verify table content"
                )
            );
        }
    }
    
    /**
     * Strict comparator :
     * - == / !=, <>: string comparison only (no numeric/date coercion).
     * - >, <, >=, <=: strict numeric or strict ISO date compare. If parsing fails, returns false.
     */
    private function compareCell(?string $cellText, $expected, string $cmp): bool
    {
        $cellText = (string)$cellText;

        switch ($cmp) {
            case '==':
                if (is_array($expected)) return false;
                return $this->normalizeText($cellText) === $this->normalizeText((string)$expected);

            case '!=':
            case '<>':
                if (is_array($expected)) return false;
                return $this->normalizeText($cellText) !== $this->normalizeText((string)$expected);

            case '>':
            case '<':
            case '>=':
            case '<=':
            {
                // Parse both sides to the same strict type (number or ISO date). Otherwise, fail.
                [$cv, $typeC] = $this->parseComparableStrict($cellText, $expected);
                [$ev, $typeE] = $this->parseComparableStrict((string)$expected, $expected);
                if ($cv === null || $ev === null || $typeC !== $typeE) {
                    return false;
                }

                switch ($cmp) {
                    case '>':   return $cv >  $ev;
                    case '<':   return $cv <  $ev;
                    case '>=':  return $cv >= $ev;
                    case '<=':  return $cv <= $ev;
                }
            }
            default:
                return $this->normalizeText($cellText) === $this->normalizeText((string)$expected);
        }
    }
    
    /**
     * Strict comparable parsing.
     * - If $expected is numeric (int/float), treat both as numbers; cell must be strictly numeric: ^[+-]?\d+(\.\d+)?$
     * - Else if $expected is ISO date string (YYYY-MM-DD[ HH:MM[:SS]]), treat both as timestamps.
     * - Else FAIL (return [null, null]).
     */
    private function parseComparableStrict(string $cellText, $expected): array
    {
        // strict number: dot-decimal only
        $numRe = '/^[+-]?\d+(?:\.\d+)?$/';
        if (is_int($expected) || is_float($expected) || (is_string($expected) && preg_match($numRe, $expected))) {
            if (preg_match($numRe, $cellText)) {
                return [(float)$cellText, 'number'];
            }
            return [null, null];
        }

        // strict date: support ISO and (optionally) current-locale strict pattern
        $locale = $this->getLocale();

        $eTs = $this->parseDateStrict((string)$expected, $locale);
        if ($eTs !== null) {
            $cTs = $this->parseDateStrict($cellText, $locale);
            if ($cTs !== null) {
                return [$cTs, 'date'];
            }
            return [null, null];
        }

        // unknown type
        return [null, null];
    }
    
    /**
     * Strict date parsing with a small whitelist of formats:
     * - ISO: YYYY-MM-DD or YYYY-MM-DD[ T]HH:MM[:SS]
     * - de_DE: dd.MM.yyyy or dd.MM.yyyy HH:MM[:SS]
     * Add more locales explicitly if needed.
     */
    private function parseDateStrict(string $s, ?string $locale): ?int
    {
        $s = trim($s);

        // ISO first (YYYY-MM-DD or with time / 'T')
        if (preg_match('/^\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2})?)?$/', $s)) {
            $ts = strtotime(str_replace('T', ' ', $s));
            return $ts === false ? null : $ts;
        }

        // Locale-specific strict formats
        if ($locale && stripos($locale, 'de_') === 0) {
            // dd.MM.yyyy or dd.MM.yyyy HH:MM[:SS]
            if (preg_match('/^\d{2}\.\d{2}\.\d{4}(?: \d{2}:\d{2}(?::\d{2})?)?$/', $s)) {
                // Convert dd.MM.yyyy[ time] -> YYYY-MM-DD[ time] for reliable strtotime
                if (preg_match('/^(\d{2})\.(\d{2})\.(\d{4})(?: (.*))?$/', $s, $m)) {
                    $day  = $m[1];
                    $mon  = $m[2];
                    $year = $m[3];
                    $time = isset($m[4]) ? ' ' . $m[4] : '';
                    $iso  = sprintf('%04d-%02d-%02d%s', (int)$year, (int)$mon, (int)$day, $time);
                    $ts   = strtotime($iso);
                    return $ts === false ? null : $ts;
                }
            }
        }

        // Not a supported strict date format
        return null;
    }


    private function normalizeText(?string $s): string
    {
        $s = (string)$s;
        $s = trim($s);
        $s = preg_replace('/\s+/u', ' ', $s);
        return mb_strtolower($s);
    }
    
    /** 
     * Extracts robust text from a cell by reading common UI5 text carriers and stripping HTML/nbsp. 
     */
    private function extractCellText(NodeElement $cell): string
    {
        // 1) Special-case: sap.m.ProgressIndicator
        $pi = $cell->find('css', '[role="progressbar"].sapMPI');
        if ($pi) {
            // Prefer aria-valuetext if present (most reliable business text)
            $vt = trim((string)$pi->getAttribute('aria-valuetext'));
            if ($vt !== '') {
                return $vt;
            }
            // Fall back to left/right texts
            $left  = $pi->find('css', '.sapMPITextLeft');
            $right = $pi->find('css', '.sapMPITextRight');
            $parts = [];
            if ($left)  { $t = trim($left->getText());  if ($t !== '') $parts[] = $t; }
            if ($right) { $t = trim($right->getText()); if ($t !== '') $parts[] = $t; }
            if (!empty($parts)) {
                return implode(' ', $parts);
            }
            // As a last resort use title (often a descriptive tooltip)
            $title = trim((string)$pi->getAttribute('title'));
            if ($title !== '') {
                return $title;
            }
            // If nothing found, return empty
            return '';
        }

        // 2) Common UI5 text carriers (labels, text, link, object status, etc.)
        $candidates = $cell->findAll('css', implode(', ', [
            '.sapMText', '.sapMLabel', '.sapMLnk', '.sapMLink',
            '.sapMObjectNumber', '.sapMObjectIdentifierTitle', '.sapMObjectIdentifierText',
            '.sapMObjStatusText', '.sapMObjStatus .sapMObjStatusText',
            '.sapMPITextLeft', '.sapMPITextRight',
            'input', 'textarea', 'select'
        ]));

        $parts = [];
        foreach ($candidates as $el) {
            $t = trim($el->getText());
            if ($t !== '') { $parts[] = $t; }
        }
        if (!empty($parts)) {
            return trim(implode(' ', $parts));
        }

        // Fallback: strip inner HTML (helps with &nbsp;)
        $html = $cell->getHtml();
        $html = html_entity_decode($html, ENT_QUOTES | ENT_HTML5, 'UTF-8');
        $html = str_replace("\xc2\xa0", ' ', $html);
        $text = trim(preg_replace('/\s+/u', ' ', strip_tags($html)));
        return $text;
    }
    
    /**
     * Initializes XHR and AJAX Request Monitoring System
     * 
     * This function sets up a comprehensive monitoring system for all network requests by:
     * - Creating a wrapper around XMLHttpRequest without modifying its core functionality (Uses wrapper pattern instead of modifying original XHR)
     * - Monitoring jQuery AJAX calls through $.ajaxSetup
     * - Tracking all fetch API requests , Catches HTTP errors (400, 500 etc.)
     * 
     * Features:
     * - Captures all network activity including status codes and responses
     * - Detects HTTP errors (400, 500 etc.) and UI5 specific errors
     * - Logs detailed request information (timestamps, duration, responses)
     * - Stores logs separately in window.exfXHRLog without affecting application
     * 
     * Use Cases:
     * - Test automation error detection
     * - Network request debugging
     * - Error state capturing
     * - Automatic error logging
     * 
     * @method initializeXHRMonitoring
     * @return void
     * @throws \RuntimeException if XHR monitoring initialization fails
     */
    public function initializeXHRMonitoring(): void
    {
        $this->getSession()->evaluateScript(
            <<<JS
            (function() {
                // Global error manager
                window.exfErrorManager = {
                    processedErrors: new Set(),
                    addError: function(error) {
                        const hash = this.generateErrorHash(error);
                        if (!this.processedErrors.has(hash)) {
                            this.processedErrors.add(hash);
                            console.error('Error logged:', error);
                        }
                    },
                    generateErrorHash: function(error) {
                        const url = (error.url || '').replace(/[?&][^=]*=[^&]*/g, '');
                        return `\${error.type}|\${error.status}|\${url}`;
                    }
                };

                // XHR logging object with improved error handling
                window.exfXHRLog = {
                    requests: [],
                    errors: [],
                    addRequest: function(request) {
                        request.timestamp = new Date().toISOString();
                        this.requests.push(request);
                        
                        if (request.status >= 400) {
                            const error = {
                                type: 'Network',
                                status: request.status,
                                url: request.url,
                                message: request.statusText,
                                response: request.response,
                                timestamp: request.timestamp
                            };
                            
                            window.exfErrorManager.addError(error);
                            this.errors.push(error);
                        }
                    }
                };

                // Enhance jQuery AJAX monitoring
                if (typeof jQuery !== 'undefined') {
                    const originalAjax = jQuery.ajax;
                    jQuery.ajax = function(options) {
                        const startTime = Date.now();
                        const originalComplete = options.complete;
                        
                        options.complete = function(jqXHR, textStatus) {
                            try {
                                const request = {
                                    url: options.url,
                                    method: options.type || 'GET',
                                    status: jqXHR.status,
                                    statusText: jqXHR.statusText,
                                    response: jqXHR.responseText,
                                    duration: Date.now() - startTime
                                };
                                
                                window.exfXHRLog.addRequest(request);
                                
                                if (originalComplete) {
                                    originalComplete.apply(this, arguments);
                                }
                            } catch (e) {
                                window.exfErrorManager.addError({
                                    type: 'JSError',
                                    message: e.message,
                                    stack: e.stack
                                });
                            }
                        };
                        
                        return originalAjax.apply(this, arguments);
                    };
                }

                // Enhanced fetch API monitoring
                if (typeof window.fetch === 'function') {
                    const originalFetch = window.fetch;
                    window.fetch = async function(input, init) {
                        const startTime = Date.now();
                        const url = typeof input === 'string' ? input : input.url;
                        const method = init?.method || 'GET';
                        
                        try {
                            const response = await originalFetch.apply(this, arguments);
                            const clone = response.clone();
                            const responseText = await clone.text();
                            
                            window.exfXHRLog.addRequest({
                                url: url,
                                method: method,
                                status: response.status,
                                statusText: response.statusText,
                                response: responseText,
                                duration: Date.now() - startTime
                            });
                            
                            return response;
                        } catch (error) {
                            const errorDetails = {
                                url: url,
                                method: method,
                                status: 0,
                                statusText: error.message,
                                error: error.toString(),
                                duration: Date.now() - startTime
                            };
                            
                            window.exfXHRLog.addRequest(errorDetails);
                            window.exfErrorManager.addError({
                                type: 'FetchError',
                                message: error.message,
                                url: url
                            });
                            
                            throw error;
                        }
                    };
                }

                console.log('Enhanced XHR monitoring initialized successfully');
            })();
            JS
        );

        // Verify initialization
        $isInitialized = $this->getSession()->evaluateScript(
            'return typeof window.exfXHRLog !== "undefined" && typeof window.exfXHRLog.addRequest === "function"'
        );

        if (!$isInitialized) {
            throw new \RuntimeException('XHR monitoring initialization failed');
        }
    }




    /**
     * Finds an input element by its associated label caption in a UI5 application
     * 
     * This function performs a hierarchical search to find input elements:
     * 1. First finds the label element with matching caption
     * 2. Then locates the corresponding input through the label's 'for' attribute
     * 3. Handles different UI5 input structures and nested elements
     * 
     * @param string $caption The label text to search for
     * @param \Behat\Mink\Element\NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found input element or null if not found
     */
    public function findInputByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        // Get the page or use provided parent element as search context
        $page = $this->getPage();
        $input = null;

        // Find all label BDI elements (UI5 uses BDI for bidirectional text support)
        $labelBdis = ($parent ?? $page)->findAll('css', 'label.sapMLabel > span > bdi');

        // Iterate through found labels to locate matching one
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                try {
                    // Navigate from BDI to actual label element
                    $sapMLabel = $labelBdi->getParent()->getParent();
                    $labelFor = $sapMLabel->getAttribute('for');

                    // First attempt: Try to find input directly by ID
                    $input = ($parent ?? $page)->findById($labelFor);

                    // Second attempt: Look for inner input element
                    // UI5 often wraps inputs in containers with -inner suffix
                    if (!$input) {
                        $input = ($parent ?? $page)->find('css', '#' . $labelFor . '-inner');
                    }

                    // Third attempt: Check for nested input within container
                    // Some UI5 controls have complex DOM structures
                    if (!$input) {
                        $inputContainer = ($parent ?? $page)->find('css', '#' . $labelFor);
                        if ($inputContainer) {
                            $input = $inputContainer->find('css', 'input.sapMInputBaseInner');
                        }
                    }
                    // If input found, break the loop
                    if ($input) {
                        break;
                    }
                } catch (\Exception $e) {
                    continue;
                }
            }
        }

        return $input;
    }

    /**
     * Finds a tab element by its caption text
     * 
     * @param string $caption The tab caption to search for
     * @param NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found tab element or null if not found
     */
    public function findTabByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $selectors = ['.sapMITBItem .sapMITHTextContent ', '.sapUxAPAnchorBarScrollContainer > div > button.sapMBtn > span > span > bdi'];
        // Find all tab heading elements
        $tabHeadings = ($parent ?? $this->getPage())->findAll('css', implode(',', $selectors));

        // Iterate through found tab headings to locate matching one
        foreach ($tabHeadings as $tabHeading) {
            if ($tabHeading->getText() === $caption && $tabHeading->isVisible()) {
                // Return the parent tab element (navigate up to the actual tab container)
                return $tabHeading->getParent()->getParent()->getParent();
            }
        }
        return null;
    }

    /**
     * Finds a column by its caption text
     * 
     * @param string $caption The column caption to search for
     * @param NodeElement|FacadeNodeInterface|null $parent Optional parent element to search within
     * @return NodeElement|null The found column element or null if not found
     */
    public function findColumnByCaption(string $caption, $parent = null): ?NodeElement
    {
        // FacadeNodeInterface ise NodeElement'e dönüştür
        if ($parent instanceof FacadeNodeInterface) {
            // UI5AbstractNode sınıfı getNodeElement() metodunu kullanıyor
            $parent = $parent->getNodeElement();
        }

        $columnHeadings = ($parent ?? $this->getPage())->findAll('css', '.sapUiTableHeaderCell');

        // Iterate through found column headings to locate matching one
        foreach ($columnHeadings as $columnHeading) {
            if ($columnHeading->getText() === $caption && $columnHeading->isVisible()) {
                // Return the column element
                return $columnHeading;
            }
        }
        return null;
    }

    /**
     * Navigates to a specific tab by caption
     * If the tab is not already active, clicks it to activate
     * 
     * @param string $caption Tab caption to find and navigate to
     * @param NodeElement|null $parent Optional parent element to search within
     * @param int $attempts Number of attempts to find the tab
     * @return NodeElement|null The found tab element or null if not found
     * @throws \PHPUnit\Framework\AssertionFailedError If tab cannot be found
     */
    public function goToTab(string $caption, NodeElement $parent = null, int $attempts = 1): ?NodeElement
    {
        $tab = $this->findTabByCaption($caption, $parent);
        if ($tab === null && $attempts > 1) {
            // Try again after waiting for UI updates
            $attempts--;
            return $this->goToTab($caption, $parent, $attempts);
        }
        Assert::assertNotNull($tab, 'Cannot find tab "' . $caption . '"');
        // If the tab is not active, click on it to switch to the right authenticator
        if (!$tab->hasClass('sapMITBSelected')) {
            $tab->click();
        }
        return $tab;
    }

    /**
     * Finds a button element by its caption text
     * 
     * @param string $caption The button text to search for
     * @param NodeElement|null $parent Optional parent element to search within
     * @return NodeElement|null The found button element or null if not found
     */
    public function findButtonByCaption(string $caption, NodeElement $parent = null): ?NodeElement
    {
        $page = $this->getPage();
        $button = null;
        // Find all button elements with BDI text container
        $labelBdis = ($parent ?? $page)->findAll('css', 'button.sapMBtn > span > span > bdi');
        // Check each button's text content
        foreach ($labelBdis as $labelBdi) {
            if ($labelBdi->getText() === $caption) {
                // Navigate up to the actual button element
                $button = $labelBdi->getParent()->getParent()->getParent();
                break;
            }
        }
        return $button;
    }


    /**
     * Finds the latest downloaded XLSX file
     * 
     * @return string|null Full path of the downloaded file
     */
    public function findLatestXlsxFile(): ?string
    {
        $config = $this->getWorkbench()->getApp('axenox.BDT')->getConfig();
        $downloadDir = $config->getOption('TEST_DOWNLOADS.DIRECTORY_WINDOWS');

        // Find XLSX files modified in the last 2 minutes 
        $twoMinutesAgo = time() - 120;

        $files = scandir($downloadDir, SCANDIR_SORT_DESCENDING);
        foreach ($files as $file) {
            $filePath = $downloadDir . DIRECTORY_SEPARATOR . $file;

            if (
                is_file($filePath) &&
                strtolower(pathinfo($file, PATHINFO_EXTENSION)) === 'xlsx' &&
                filemtime($filePath) >= $twoMinutesAgo
            ) {
                return $filePath;
            }
        }

        return null;
    }



    /**
     * Finds and returns visible widgets based on specific criteria
     * 
     * This method performs a comprehensive search for UI5 widgets with the following features:
     * - Searches for widgets using a generalized CSS selector
     * - Waits for pending operations to complete before searching
     * - Filters widgets by type and optional object alias
     * - Ensures only visible widgets are returned
     * 
     * @param string $widgetType The type of widget to search for (e.g., 'DataTable')
     * @param string|null $objectAlias Optional text to filter widgets by their title or content
     * @param int $timeoutInSeconds Maximum time to wait for widgets to be available (default: 10 seconds)
     * 
     * @return NodeElement[] Array of visible widget nodes matching the search criteria
     * 
     * Search Strategy:
     * - Uses CSS class-based widget identification
     * - Performs visibility and alias-based filtering
     * - Supports case-insensitive partial matching for object alias
     */
    public function findWidgets(string $widgetType, ?string $objectAlias = null, int $timeoutInSeconds = 10): array
    {
        // Generate a generalized CSS selector for the specific widget type
        $cssSelector = ".exfw-{$widgetType}";

        // Wait for all pending operations to complete
        $this->waitManager->waitForPendingOperations(true, true, true);
        if ($timeoutInSeconds > 0) {
            $this->waitManager->waitForDOMElements($cssSelector, $timeoutInSeconds);
        }
        // Find all widgets on the page matching the CSS selector
        $page = $this->getPage();
        $widgets = $page->findAll('css', $cssSelector);

        // Filter widgets based on visibility and optional object alias
        $visibleWidgets = array_filter($widgets, function ($widget) use ($objectAlias) {

            // Return only visible widgets
            return $widget->isVisible();
        });

        return $visibleWidgets;
    }

    /**
     * Summary of findWidgetNodes
     * @param string $widgetType
     * @param int $timeoutInSeconds
     * @return FacadeNodeInterface[]
     */
    public function findWidgetNodes(string $widgetType, int $timeoutInSeconds = 10): array
    {
        // Generate a generalized CSS selector for the specific widget type
        $cssSelector = ".exfw-{$widgetType}";

        // Wait for all pending operations to complete
        $this->waitManager->waitForPendingOperations(true, true, true);
        if ($timeoutInSeconds > 0) {
            $this->waitManager->waitForDOMElements($cssSelector, 1, $timeoutInSeconds);
        }

        // Find all widgets on the page matching the CSS selector 
        $widgets = $this->getFocusedNode()->getNodeElement()->findAll('css', $cssSelector);

        // If no widgets found, fallback to page-wide search
        if (empty($widgets)) {
            $page = $this->getPage();
            $widgets = $page->findAll('css', $cssSelector);
        }

        $nodes = [];
        foreach ($widgets as $nodeEl) {
            if (!$nodeEl->isVisible()) {
                continue;
            }
            $nodes[] = UI5FacadeNodeFactory::createFromNodeElement($widgetType, $nodeEl, $this->getSession(), $this);
        }

        return $nodes;
    }


    /**
     * Summary of findTiles
     * 
     * @return \axenox\BDT\Behat\Contexts\UI5Facade\Nodes\UI5TileNode[]
     */
    public function findTiles(): array
    {
        // Find tiles on the page
        $nodes = $this->findWidgets("Tile");

        // Store the tile names on the page
        $tiles = [];
        foreach ($nodes ?? [] as $node) {
            $tile = new UI5TileNode($node, $this->getSession(), $this);
            $tiles[] = $tile;
        }
        Assert::assertNotEmpty($tiles, 'No tiles found');
        return $tiles;
    }

    /**
     * Find a button within exfw-datatable with exact text match
     * 
     * This method searches for buttons inside exfw-datatable divs
     * with a specific text in the <bdi> element
     * 
     * @param string $buttonText The exact text to search for in the button
     * @param string|null $tableName Optional table/section name to narrow down search
     * @return NodeElement|null The found button or null if not found
     */
    public function findButton(string $buttonText, string $tableName = null): ?NodeElement
    {
        // Construct base XPath to find buttons in exfw-datatable with exact <bdi> text
        $xpath = sprintf(
            "//div[contains(@class, 'exfw-datatable')]" .  // Find within datatable divs
            "//button[.//bdi[text()='%s']]",  // Button with <bdi> containing exact text
            $buttonText
        );

        // If a specific table/section name is provided, refine the search
        if ($tableName) {
            $xpath = sprintf(
                "//div[contains(@class, 'exfw-datatable') and contains(@id, '%s')]" . // Specific datatable
                "//button[.//bdi[text()='%s']]",  // Button with exact text
                $tableName,
                $buttonText
            );
        }

        // Perform the XPath search and return the result
        $button = $this->getSession()->find('xpath', $xpath);

        return $button;
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     * @param NodeElement $element Element to check
     * @return bool True if element is a valid dialog
     */
    protected function isValidDialog(NodeElement $element): bool
    {
        try {
            // Must be visible
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$element->isVisible()) {
                return false;
            }

            // Check for essential dialog attributes
            $role = $element->getAttribute('role');
            $classes = $element->getAttribute('class');

            // Must have dialog role or specific dialog classes
            if (
                $role !== 'dialog' &&
                !preg_match('/(sapMDialog|sapMMessageDialog|sapMPopover)/', $classes)
            ) {
                return false;
            }

            // Should have either a header or content section
            $hasHeader = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX') !== null;
            $hasContent = $element->find('css', '.sapMDialogSection, .sapMDialogContent') !== null;

            return $hasHeader || $hasContent;

        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Extracts text content from a dialog element
     * 
     * @param NodeElement $element Dialog element
     * @return string Concatenated text content
     */
    protected function extractDialogText(NodeElement $element): string
    {
        $textParts = [];

        try {
            // Get header title 
            $headerTitle = $element->find('css', '.sapMDialogTitle, .sapMIBar-CTX .sapMTitle');
            if ($headerTitle) {
                $textParts[] = trim($headerTitle->getText());
            }

            // Get content text
            $textElements = $element->findAll('css', '.sapMDialogContent .sapMText, .sapMDialogContent .sapMLabel');
            foreach ($textElements as $textElement) {
                $text = trim($textElement->getText());
                if (!empty($text)) {
                    $textParts[] = $text;
                }
            }

            // Get button texts
            $buttons = $element->findAll('css', '.sapMDialogFooter .sapMBtn, .sapMBar-CTX .sapMBtn');
            foreach ($buttons as $button) {
                $buttonText = $button->find('css', '.sapMBtnContent');
                if ($buttonText) {
                    $textParts[] = trim($buttonText->getText());
                }
            }

        } catch (\Exception $e) {
            // If any error occurs, return empty string
            return '';
        }

        return implode(' ', array_filter($textParts));
    }

    /**
     * Validates if a DOM element represents a proper UI5 table structure
     *  
     * 
     * @param NodeElement $table The element to validate as a table
     * @return bool True if element is a valid UI5 table, false otherwise
     */
    protected function isValidTable(NodeElement $table): bool
    {
        try {
            // First check: Element must be visible in the DOM
            // This ensures we're not processing hidden template elements
            if (!$table->isVisible()) {
                return false;
            }

            // Second check: Look for table structural elements
            // Search for both standard table headers (th) and UI5 grid headers (role="columnheader")
            $hasHeaders = count($table->findAll('css', 'th, [role="columnheader"]')) > 0;
            // Third check: Look for table cells
            // Search for both standard cells (td) and UI5 grid cells (role="gridcell")
            $hasCells = count($table->findAll('css', 'td, [role="gridcell"]')) > 0;

            // A valid table must have either headers or cells
            // - Headers without cells: Empty table with column definitions
            // - Cells without headers: Data grid without column labels
            // - Both headers and cells: Standard populated table
            return $hasHeaders || $hasCells;

        } catch (\Exception $e) {
            // If any error occurs during validation (e.g., stale element reference)
            // consider the table invalid
            return false;
        }
    }

    /**
     * Returns the type of the widget, that the given node belongs to
     * 
     * @param \Behat\Mink\Element\NodeElement $node
     * @return bool|string|null
     */
    public function getNodeWidgetType(NodeElement $node): ?string
    {
        $classes = $node->getAttribute('class');
        $type = null;
        foreach (explode(' ', $classes ?? '') as $class) {
            if (mb_stripos($class, 'exfw-') === 0) {
                $type = StringDataType::substringAfter($class, 'exfw-');
            }
        }
        if ($type === null) {
            // TODO search the parents of the node for the first one with `exfw` CSS class
            // and take the widget type from that node
        }
        return $type;
    }



    /**
     * 
     * @param string $pageUrl
     * @param string $widgetId
     * @param string $assertWidgetType
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    protected function getWidget(string $pageUrl, string $widgetId = null, string $assertWidgetType = null)
    {
        $page = UiPageFactory::createFromModel($this->getWorkbench(), $pageUrl);
        $widget = $widgetId !== null ? $page->getWidget($widgetId) : $page->getWidgetRoot();
        if ($assertWidgetType !== null) {
            Assert::assertEquals($assertWidgetType, $widget->getType(), 'Widget ' . $widgetId . ' is not of expected type "' . $assertWidgetType . '"!');
        }
        return $widget;
    }


    public static function setupUser(WorkbenchInterface $workbench, array $roles, string $locale = null): array
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $userSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER');
        $userSheet->getFilters()->addConditionFromString('USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $userSheet->getColumns()->addFromSystemAttributes();
        $userSheet->getColumns()->addMultiple([
            'USERNAME'
        ]);
        $userSheet->dataRead();
        if ($userSheet->isEmpty()) {
            $userSheet->addRow([
                'USERNAME' => $config->getOption('TEST_USER.USERNAME'),
                'PASSWORD' => $config->getOption('TEST_USER.PASSWORD'),
                'FIRST_NAME' => $config->getOption('TEST_USER.FIRST_NAME'),
                'LAST_NAME' => $config->getOption('TEST_USER.LAST_NAME'),
                'LOCALE' => $workbench->getConfig()->getOption('SERVER.DEFAULT_LOCALE')
            ]);
            $userSheet->dataCreate();
        }
        $userId = $userSheet->getUidColumn()->getValue(0);

        if ($locale) {
            $userSheet->setCellValue('LOCALE', 0, $locale);
        }

        if (!empty($roles)) {
            $roleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE');
            $roleSheet->getColumns()->addFromSystemAttributes();
            $roleSheet->getFilters()
                ->addNestedOR()
                ->addConditionFromValueArray('ALIAS_WITH_NS', $roles)
                ->addConditionFromValueArray('NAME', $roles);
            $roleSheet->dataRead();
            Assert::assertEquals(count($roles), $roleSheet->countRows(), 'Not all rows found!');

            $userRoleSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
            $userRoleSheet->getFilters()->addConditionFromString('USER', $userId);
            foreach ($roleSheet->getUidColumn()->getValues() as $roleUid) {
                $userRoleSheet->addRow([
                    'USER_ROLE' => $roleUid
                ]);
            }
            $userSheet->setCellValue('USER_ROLE_USERS', 0, $userRoleSheet->exportUxonObject()->toArray());
        }
        $userSheet->dataUpdate();

        $loginFields = [];
        foreach ($workbench->getConfig()->getOption('SECURITY.AUTHENTICATORS') as $authUxon) {
            if ($authUxon->getProperty('class') === '\\' . MetamodelAuthenticator::class) {
                $loginDataObj = MetaObjectFactory::createFromString($workbench, 'exface.Core.LOGIN_DATA');
                $loginFields['_tab'] = $authUxon->getProperty('name') ?? $workbench->getCoreApp()->getTranslator()->translate('SECURITY.SIGN_IN');
                $loginFields[$loginDataObj->getAttribute('USERNAME')->getName()] = $config->getOption('TEST_USER.USERNAME');
                $loginFields[$loginDataObj->getAttribute('PASSWORD')->getName()] = $config->getOption('TEST_USER.PASSWORD');
                $loginAction = ActionFactory::createFromString($workbench, Login::class);
                $loginFields['_button'] = $loginAction->getName();
            }
        }
        return $loginFields;
    }

    public static function resetUser(WorkbenchInterface $workbench): void
    {
        $config = $workbench->getApp('axenox.BDT')->getConfig();
        $dataSheet = DataSheetFactory::createFromObjectIdOrAlias($workbench, 'exface.Core.USER_ROLE_USERS');
        $dataSheet->getFilters()->addConditionFromString('USER__USERNAME', $config->getOption('TEST_USER.USERNAME'), ComparatorDataType::EQUALS);
        $dataSheet->dataDelete();
        return;
    }

    private function getCurrentUrlInfo(): array
    {

        return $this->getSession()->evaluateScript('
        (function() {
            var baseUrl = window.location.href.split("#")[0];
            var fullUrl = window.location.href;
            
            // UI5 specific routing information
            var ui5Hash = "";
            if (typeof sap !== "undefined" && 
                sap.ui && 
                sap.ui.core && 
                sap.ui.core.routing && 
                sap.ui.core.routing.HashChanger) {
                
                try {
                    // Get the current hash from UI5 router
                    ui5Hash = sap.ui.core.routing.HashChanger.getInstance().getHash();
                } catch(e) {
                    ui5Hash = window.location.hash.replace("#", "");
                }
            } else {
                ui5Hash = window.location.hash.replace("#", "");
            }
            
            return {
                baseUrl: baseUrl,
                fullUrl: fullUrl,
                hash: ui5Hash
            };
        })()
    ');
    }

    /**
     * Summary of getFilters
     * @param int $min
     * @param int $max
     * @param FacadeNodeInterface $withinNode
     * @throws \RuntimeException
     * @return UI5FilterNode[]
     */
    public function getFilters(int $min = 1, int $max = null): array
    {
        $nodes = $this->findWidgetNodes('Filter', 15);
        $nodes = array_merge($nodes, $this->findWidgetNodes('RangeFilter', 15));

        switch (true) {
            case count($nodes) < $min:
                throw new RuntimeException("Too few filters found: expecting {$min} but found " . count($nodes));
            case $max !== null && count($nodes) > $max:
                throw new RuntimeException("Too many filters found: expecting {$max} but found " . count($nodes));
        }
        return $nodes;
    }

    public function getFilterByCaption(string $filterName): UI5FilterNode
    {
        $filterNodes = $this->getFilters();

        // Iterate through each filter container
        foreach ($filterNodes as $filterNode) {
            // Check the label of the filter container
            $label = $filterNode->getCaption();

            // If label matches the desired filter name
            if ($label === $filterName) {
                return $filterNode;
            }
        }
        throw new RuntimeException("Filter {$filterName} not found");
    }

}